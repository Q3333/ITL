# ORM(Object Relational Mapping)

#### 파이썬이 객체 지향 프로그램이라서, 데이터베이스와 객체지향언어의 중간에서 통역을 해주는 역할을 하는 것이 ORM이다.



#### 장점 : 

- SQL을 몰라도 DB에 접근할 수 있다.
- SQL문이 아니기 때문에 코드의 가독성이 좋아진다.
- 인스턴스를 생성해서 계속 접근 가능하기 때문에(객체 지향적인 접근) 생산성이 좋아진다.
- 맵핑 정보가 확실하기 때문에 기존 DB에서 ERD를 봐야했던 의존성을 낮출 수 있다,
- ORM은 독립적으로 작성되어 있고, 해당 객체들을 재활용 할 수 있다.
- 모델에서 가공된 데이터를 컨트롤러(views.py)에 의해 뷰(templates)와 합쳐지는 형태로 디자인 패턴(MVC패턴)을 견고하게 다지는데 유리



#### 단점 :

- 모든것을 ORM으로 구현하기 어렵다.
- 사용은 편하나 설계에는 좀 더 신중을 기울여야 한다.
- 구조가 복잡해지면 난이도가 상승할 수 있다.
- 잘못 구현되면 속도 저하 및 일관성이 무너질 수 있다.



## MTV

모델 템플릿( mvc에서의 뷰) 뷰( mkc에서의 컨트롤러)



### DB 용어 간략 정리

##### 쿼리 : 데이터를 질의, 조회하는 명령어

##### DB : 체계화된 데이터의 모임

##### 스키마 : DB 자료의 구조, 표현방법, 관계 정의한 구조



#### 테이블

##### -필드

##### -레코드



#### 모델

- 모델은 단일 데이터에 대한 정보를 가지고 있음.

- 필수적인 필드(컬럼)과 데이터(레코드)에 대한 정보를 포함
- 각각의 모델은 각 DB 테이블과 매핑
- 사용자가 저장하는 데이터들의 필수적인 필드(컬럼) 동작을 포함







# 모델 실습



app의 모델 먼저 작성

```python
class Board(models.Model):
    title = models.CharField(max_length=10)
    #CharField는 max_length가 필요하다.
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    #auto_now_add 를 True로 하면 데이터가 들어갈 때 마다 시스템의 현재 시간을 넣어줌
```



그 후 migrations를 만들어줌.

```python
python manage.py makemigrations
```



그러면 이런 py 파일이 하나 생성됨.

```python
# Generated by Django 2.2.7 on 2019-11-14 01:47

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Board',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=10)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]

```





### 모델 확인하기



#### 명세 확인

```python
python manage.py sqlmigrate app 0001
#app 은 앱이름, 0001은 migrations의 번호
```



```bash
BEGIN;
--
-- Create model Board
--
CREATE TABLE "app_board" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(10) NOT NULL, "content" text NOT NULL, "created_at" datetime NOT NULL);
COMMIT;
```

이런 결과가 나옴.



#### 명세가 아닌 적용이 되었는지를 확인

```bash
python manage.py showmigrations
```



결과는 

```bash
admin
 [ ] 0001_initial
 [ ] 0002_logentry_remove_auto_add
 [ ] 0003_logentry_add_action_flag_choices
app
 [ ] 0001_initial
 [ ] 0002_board_updated_at
```

이런 식인데 [ ] 안이 공란이라는 건 아직 적용이 되지 않았다는 의미다.





#### migrate 적용하기

```bash
python manage.py migrate
```

이 명령어를 치면 현재 생성된 migrations들을 적용시켜준다.



결과 : 

```bash
admin
 [X] 0001_initial
 [X] 0002_logentry_remove_auto_add
 [X] 0003_logentry_add_action_flag_choices
app
 [X] 0001_initial
 [X] 0002_board_updated_at
auth
 [X] 0001_initial
```



#### 이렇게 X표시가 되면 DB를 쓸 준비가 완료가 되었다는 뜻.





# 정리

#### 1. models.py 를 작성

#### 2. makemigrations: migration 파일(명세서) 생성

#### 3. migrate : 실제 적용되는 부분(명령어)





DB파일을 보려면  https://www.sqlite.org/index.html 에서 sqlite 버전을 다운받아야함.

그 중에서  **Precompiled Binaries for Windows**  64bit파일과  sqlite-tools-win32-x86을 다운받아야함.



그 후 C드라이브에 sqlite파일을 만들고 두 파일을 합침 (5개를 한 폴더에)



```bash
vim ~/.bashrc

한 후 i를 눌러서 편집,

alias sqlite="c:/sqlite/sqlite3.exe"
(띄어쓰기 없게 주의)

그 후 esc :wq 로 저장 후 종료한 뒤,

source ~/.bashrc로 불러옴
```





#### sqlite실행법

sqlite를 치면 전용 배쉬로 접근,

나가려면 .exit



sqlite db.sqlite3 을 치면 장고의 DB파일을 볼 수 있다.

##### 그 후 .tables를 입력하면 전체 테이블을 볼 수 있음.



##### .schema 테이블 이름

을 하면 해당 테이블이 제대로 생성 되어 있는지 볼 수 있다.

```bash
.schema app_board
 
CREATE TABLE IF NOT EXISTS "app_board" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(10) NOT NULL, "content" text NOT NULL, "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL);
```

이런 결과가 나옴.



#### 장고 쉘로 실행

```bash
python manage.py shell
```



#### 쉘 에서 진행

```python
from app.models import Board
Board.objects.all()
```

app은 앱이름, Board는 모델의 클래스 이름이다.



#### Board.objects.all()은 인터페이스와 연결하는 문법

현재는 넣은 값이 없어서 이렇게 나온다.

```bash
>>> Board.objects.all()
<QuerySet []>
```



### 데이터 객체 생성 방법 - 1

```bash
>>> board = Board()
>>> board.title = "first"
>>> board.contents = "django !!!!!!"
>>> board.save()
>>> board
<Board: Board object (1)>
```

인스턴스를 생성해서 직접 값을 넣어줌. 



### 데이터 객체 생성 방법 -2

```bash
>>> board = Board(title="second", content="django")
>>> board.save()
>>> board
<Board: Board object (2)>
```

생성과 동시에 값을 입력해줌.



### 데이터 객체 생성 방법 -3

```bash
>>> Board.objects.create(title="third", content="django~~~") 
<Board: Board object (3)>
```

한줄로 생성과 동시에 save를 시켜주는 구문



1,2,3 모두 쿼리 셋에 리스트 형태로 들어가 있다.

```bash
>>> Board.objects.all()
<QuerySet [<Board: Board object (1)>, <Board: Board object (2)>, <Board: Board object (3)>]>
```





### Models 수정

```python
class Board(models.Model):
    title = models.CharField(max_length=10)
    #CharField는 max_length가 필요하다.
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    #auto_now_add 를 True로 하면 데이터가 들어갈 때 마다 시스템의 현재 시간을 넣어줌
    updated_at = models.DateTimeField(auto_now=True)
     #auto_now 는 생성이 아니라 수정될 때 마다 시간이 자동으로 등록

     def __str__(self):
         return f"{self.id} : {self.title}"
```



밑에 str함수 추가,

테이블은 수정 안하고 함수만 추가했을 때는 makemigrations를 안 해줘도 된다.

but command는 껐다켜야함.



@ 더블 언더바는 던더라고 한다고 함.



#### 커맨드 껐다 킨 뒤 배쉬 실행,

```bash
python manage.py shell

>>> from app.models import Board 
>>> Board.objects.all()
<QuerySet [<Board: 1 : first>, <Board: 2 : second>, <Board: 3 : third>]>
```

결과값이 1: first , 2: second로 잘 나오는 것을 볼 수 있음.





##### 필드 관련 메뉴얼은 여기 참고

 https://docs.djangoproject.com/en/2.2/ref/models/fields/ 



### 인스턴스 체크

**대상이름.full_clean()** 하면 board2의 인스턴스들을 보여준다.

제목 맥스 길이를 10으로 해놓고 11자를 넣을 경우 결과 :

```bash
>>> board2.full_clean()
django.core.exceptions.ValidationError: {'title': ['이 값이 최대 10 개의 글자인지 확인하세요(입력
값 11 자).'], 'content': ['이 필드는 빈 칸으로 둘 수 없습니다.']}
```



### bash의 결과 값을 다른 변수에 저장 가능

``` bash
>>> b = Board.objects.all()
>>> b
<QuerySet [<Board: 1 : first>, <Board: 2 : second>, <Board: 3 : third>, <Board: 4 : forth>]>
>>> b[0]
<Board: 1 : first>
>>> b[0].title
'first'
```



PK를 이용해서 value를 가져올 수 있음.

```bash
>>> b = Board.objects.get(pk=3) 
>>> b
<Board: 3 : third>
```



요소로도 가져올 수 있음

```bash
>>> b = Board.objects.get(title='second')
>>> b
<Board: 2 : second>
```



##### get은 하나만 가져올 수 있다. (데이터가 없을 경우 에러가 발생)

### 리스트에서 여러가지 값을 가져오는 방법 

```bash
>>> b = Board.objects.filter(title="second")
>>> b
<QuerySet [<Board: 2 : second>, <Board: 5 : second>, <Board: 6 : second>]>
```

#### filter를 사용함.



#### *ORM의 리스트(쿼리셋)는 일반 리스트와 동일해서 슬라이싱도 가능

```bash
>>> b = Board.objects.all()
>>> b
<QuerySet [<Board: 1 : first>, <Board: 2 : second>, <Board: 3 : third>, <Board: 4 : forth>, <Board: 5 : second>, <Board: 6 : second>]>
>>> b[1:3]
<QuerySet [<Board: 2 : second>, <Board: 3 : third>]>
```



참고

```bash
>>> type(b)
<class 'django.db.models.query.QuerySet'>
>>> type(b[0])
<class 'app.models.Board'>
```

Board.objects.all() 는 쿼리셋 타입,

리스트의 요소 하나 하나는 객체(class 선언한 거) 의 타입이 된다.



### like문(contains)

```bash
>>> b = Board.objects.filter(title__contains="sec")
>>> b
<QuerySet [<Board: 2 : second>, <Board: 5 : second>, <Board: 6 : second>]>
```

title에 sec가 포함된 객체들만 가져옴,

#### title 뒤에 __을 붙여줘야함!!(ex title -> title\____)







### Filter의 리턴값

filter는 결과값이 하나여도 쿼리셋으로 리턴해주기 때문에

b.title 이 아니라

b[0].title 같은 식으로 호출해야한다.

```bash
>>> b = Board.objects.filter(title__startswith="fi")
>>> b
<QuerySet [<Board: 1 : first>]>
>>> type(b)
<class 'django.db.models.query.QuerySet'>


>>> b.title
Traceback (most recent call last):
  File "<console>", line 1, in <module>
AttributeError: 'QuerySet' object has no attribute 'title'
>>> b.[0].title
  File "<console>", line 1
    b.[0].title
      ^
SyntaxError: invalid syntax


>>> b[0].title  
'first'
```



#### startswith 가 아니라 endswith도 있음

```bash
>>> b = Board.objects.filter(title__endswith="d")
>>> b
<QuerySet [<Board: 2 : second>, <Board: 3 : third>, <Board: 5 : second>, <Board: 6 : second>]>
```





#### filter가 아니라 get일경우 바로 .title로 접근 가능

```bash
 b = Board.objects.get(pk=1) 
>>> type(b)
<class 'app.models.Board'>
>>> b.title
'first'
>>> b.title = "hello orm"
>>> b
<Board: 1 : hello orm>
>>> b.save()
```

하지만 save를 하지 않으면 데이터베이스에는 저장이 되지 않는다.



#### 큰 틀은 쿼리셋 , 그 내부는 객체로 생성된다.



## 요소 지우기

요소.delete()

```bash
>>> b = Board.objects.get(pk=3)
>>> b
<Board: 3 : third>
>>> b.delete()
(1, {'app.Board': 1})
>>> Board.objects.all()
<QuerySet [<Board: 1 : hello orm>, <Board: 2 : second>, <Board: 4 : forth>, <Board: 5 : second>, <Board: 6 : second>]>
```



3이 사라짐.





## admin 계정 만들기

#### 명령어 : python manage.py createsuperuser

```bash
$ python manage.py createsuperuser
사용자 이름 (leave blank to use 'student'): 
```



비번 a12341234



![image-20191114143302616](C:\Users\student\AppData\Roaming\Typora\typora-user-images\image-20191114143302616.png)



이런식으로 관리 창에 접근할 수 있음.



### admin.py 수정하기

```bash
from django.contrib import admin
from .models import Board

# Register your models here.

admin.site.register(Board)

```

import Board(모델이름), 및 register(Board) 를 해야함.





수정하면 사이트에 APP 창이 하나 추가됨

![image-20191114144405052](C:\Users\student\AppData\Roaming\Typora\typora-user-images\image-20191114144405052.png)





## admin 디자인



```bash
from django.contrib import admin
from .models import Board

# Register your models here.

class BoardAdmin(admin.ModelAdmin):
    fields = ['content', 'title']
    #내용 순서를 콘텐츠 - 타이틀로
    list_display = ["title", "updated_at"]
    #리스트에서 보여주는 값들을 제목 + 업데이트된 날짜로
    list_filter = ["updated_at"]
    #시간 별 필터(일주일,한달 등)
    search_fields = ["title", "content"]
    #검색창

admin.site.register(Board , BoardAdmin)

```



BoardAdmin 클래스를 따로 하나 만들어주고 거기에서 편집,

그 후 register에서 Board, 말고 BoardAdmin도 같이 넣어줘야한다.



그 외 참고는  https://docs.djangoproject.com/en/2.2/ref/contrib/admin/ 





결과 : ![image-20191114152338718](C:\Users\student\AppData\Roaming\Typora\typora-user-images\image-20191114152338718.png)