# ORM(Object Relational Mapping)

#### 파이썬이 객체 지향 프로그램이라서, 데이터베이스와 객체지향언어의 중간에서 통역을 해주는 역할을 하는 것이 ORM이다.



#### 장점 : 

- SQL을 몰라도 DB에 접근할 수 있다.
- SQL문이 아니기 때문에 코드의 가독성이 좋아진다.
- 인스턴스를 생성해서 계속 접근 가능하기 때문에(객체 지향적인 접근) 생산성이 좋아진다.
- 맵핑 정보가 확실하기 때문에 기존 DB에서 ERD를 봐야했던 의존성을 낮출 수 있다,
- ORM은 독립적으로 작성되어 있고, 해당 객체들을 재활용 할 수 있다.
- 모델에서 가공된 데이터를 컨트롤러(views.py)에 의해 뷰(templates)와 합쳐지는 형태로 디자인 패턴(MVC패턴)을 견고하게 다지는데 유리



#### 단점 :

- 모든것을 ORM으로 구현하기 어렵다.
- 사용은 편하나 설계에는 좀 더 신중을 기울여야 한다.
- 구조가 복잡해지면 난이도가 상승할 수 있다.
- 잘못 구현되면 속도 저하 및 일관성이 무너질 수 있다.



## MTV

모델 템플릿( mvc에서의 뷰) 뷰( mkc에서의 컨트롤러)



### DB 용어 간략 정리

##### 쿼리 : 데이터를 질의, 조회하는 명령어

##### DB : 체계화된 데이터의 모임

##### 스키마 : DB 자료의 구조, 표현방법, 관계 정의한 구조



#### 테이블

##### -필드

##### -레코드



#### 모델

- 모델은 단일 데이터에 대한 정보를 가지고 있음.

- 필수적인 필드(컬럼)과 데이터(레코드)에 대한 정보를 포함
- 각각의 모델은 각 DB 테이블과 매핑
- 사용자가 저장하는 데이터들의 필수적인 필드(컬럼) 동작을 포함







# 모델 실습



app의 모델 먼저 작성

```python
class Board(models.Model):
    title = models.CharField(max_length=10)
    #CharField는 max_length가 필요하다.
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    #auto_now_add 를 True로 하면 데이터가 들어갈 때 마다 시스템의 현재 시간을 넣어줌
```



그 후 migrations를 만들어줌.

```python
python manage.py makemigrations
```



그러면 이런 py 파일이 하나 생성됨.

```python
# Generated by Django 2.2.7 on 2019-11-14 01:47

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Board',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=10)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]

```





### 모델 확인하기



#### 명세 확인

```python
python manage.py sqlmigrate app 0001
#app 은 앱이름, 0001은 migrations의 번호
```



```bash
BEGIN;
--
-- Create model Board
--
CREATE TABLE "app_board" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(10) NOT NULL, "content" text NOT NULL, "created_at" datetime NOT NULL);
COMMIT;
```

이런 결과가 나옴.



#### 명세가 아닌 적용이 되었는지를 확인

```bash
python manage.py showmigrations
```



결과는 

```bash
admin
 [ ] 0001_initial
 [ ] 0002_logentry_remove_auto_add
 [ ] 0003_logentry_add_action_flag_choices
app
 [ ] 0001_initial
 [ ] 0002_board_updated_at
```

이런 식인데 [ ] 안이 공란이라는 건 아직 적용이 되지 않았다는 의미다.





#### migrate 적용하기

```bash
python manage.py migrate
```

이 명령어를 치면 현재 생성된 migrations들을 적용시켜준다.



결과 : 

```bash
admin
 [X] 0001_initial
 [X] 0002_logentry_remove_auto_add
 [X] 0003_logentry_add_action_flag_choices
app
 [X] 0001_initial
 [X] 0002_board_updated_at
auth
 [X] 0001_initial
```



#### 이렇게 X표시가 되면 DB를 쓸 준비가 완료가 되었다는 뜻.





# 정리

#### 1. models.py 를 작성

#### 2. makemigrations: migration 파일(명세서) 생성

#### 3. migrate : 실제 적용되는 부분(명령어)





DB파일을 보려면  https://www.sqlite.org/index.html 에서 sqlite 버전을 다운받아야함.

그 중에서  **Precompiled Binaries for Windows**  64bit파일과  sqlite-tools-win32-x86을 다운받아야함.



그 후 C드라이브에 sqlite파일을 만들고 두 파일을 합침 (5개를 한 폴더에)



```bash
vim ~/.bashrc

한 후 i를 눌러서 편집,

alias sqlite="c:/sqlite/sqlite3.exe"
(띄어쓰기 없게 주의)

그 후 esc :wq 로 저장 후 종료한 뒤,

source ~/.bashrc로 불러옴
```





#### sqlite실행법

sqlite를 치면 전용 배쉬로 접근,

나가려면 .exit



sqlite db.sqlite3 을 치면 장고의 DB파일을 볼 수 있다.

##### 그 후 .tables를 입력하면 전체 테이블을 볼 수 있음.



##### .schema 테이블 이름

을 하면 해당 테이블이 제대로 생성 되어 있는지 볼 수 있다.

```bash
.schema app_board
 
CREATE TABLE IF NOT EXISTS "app_board" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(10) NOT NULL, "content" text NOT NULL, "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL);
```

이런 결과가 나옴.



#### 장고 쉘로 실행

```bash
python manage.py shell
```



#### 쉘 에서 진행

```python
from app.models import Board
Board.objects.all()
```

app은 앱이름, Board는 모델의 클래스 이름이다.



#### Board.objects.all()은 인터페이스와 연결하는 문법

현재는 넣은 값이 없어서 이렇게 나온다.

```bash
>>> Board.objects.all()
<QuerySet []>
```



### 데이터 객체 생성 방법 - 1

```bash
>>> board = Board()
>>> board.title = "first"
>>> board.contents = "django !!!!!!"
>>> board.save()
>>> board
<Board: Board object (1)>
```

인스턴스를 생성해서 직접 값을 넣어줌. 



### 데이터 객체 생성 방법 -2

```bash
>>> board = Board(title="second", content="django")
>>> board.save()
>>> board
<Board: Board object (2)>
```

생성과 동시에 값을 입력해줌.



### 데이터 객체 생성 방법 -3

```bash
>>> Board.objects.create(title="third", content="django~~~") 
<Board: Board object (3)>
```

한줄로 생성과 동시에 save를 시켜주는 구문



1,2,3 모두 쿼리 셋에 리스트 형태로 들어가 있다.

```bash
>>> Board.objects.all()
<QuerySet [<Board: Board object (1)>, <Board: Board object (2)>, <Board: Board object (3)>]>
```





### Models 수정

```python
class Board(models.Model):
    title = models.CharField(max_length=10)
    #CharField는 max_length가 필요하다.
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    #auto_now_add 를 True로 하면 데이터가 들어갈 때 마다 시스템의 현재 시간을 넣어줌
    updated_at = models.DateTimeField(auto_now=True)
     #auto_now 는 생성이 아니라 수정될 때 마다 시간이 자동으로 등록

     def __str__(self):
         return f"{self.id} : {self.title}"
```



밑에 str함수 추가,

테이블은 수정 안하고 함수만 추가했을 때는 makemigrations를 안 해줘도 된다.

but command는 껐다켜야함.



@ 더블 언더바는 던더라고 한다고 함.



#### 커맨드 껐다 킨 뒤 배쉬 실행,

```bash
python manage.py shell

>>> from app.models import Board 
>>> Board.objects.all()
<QuerySet [<Board: 1 : first>, <Board: 2 : second>, <Board: 3 : third>]>
```

결과값이 1: first , 2: second로 잘 나오는 것을 볼 수 있음.



